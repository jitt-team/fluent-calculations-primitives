<?xml version="1.0" encoding="utf-8" ?>
<docs>
	<members name="EvaluationScopeGeneric">
		<class>
			<summary>
				Base class for implementing a calculation.
			</summary>
			<remarks>
				<para>
					Use this class to define, run and retrieve a result of your calculations.
				</para>
				<list type="table">
					<item>
						<term>EvaluationScope</term>
						<description>
							<para></para>
							EvaluationScope<![CDATA[<T>]]> is a logical compostion of lambda expressions implementing operations with input parameters or <br/>
							types derived from <see cref="Value"/>. Purpose of EvaluationScope<![CDATA[<T>]]> derived type is to ouput a single value as a result.
						</description>
					</item>
					<item>
						<term>Examples</term>
						<description>
							<para>See below a class inheriting from EvaluationScope<![CDATA[<T>]]>, where T is a calculations result type.</para>
							<code>
								public class ExampleEvaluationScope : EvaluationScope<![CDATA[<Number>]]>
								{
								public ExampleEvaluationScope() : base(new EvaluationOptions { AlwaysReadNamesFromExpressions = true }) { }
								public override Number Return() => Number.Of(0);
								}
							</code>
						</description>
					</item>
					<item>
						<a href="https://github.com/jitt-team/fluent-calculations-primitives/wiki/">
							Learn more
						</a>
					</item>
				</list>
			</remarks>
			<typeparam name="T">Type of the result value class</typeparam>
		</class>
		<ctor>
			<summary>
				Initializes a new instance of the <see cref="EvaluationScope{T}"/>.
			</summary>
		</ctor>
		<ctor-options>
			<summary>
				Initializes a new instance of the <see cref="EvaluationScope{T}"/> class with custom options.
			</summary>
			<param name="options">Options to be used to run the calculation</param>
		</ctor-options>
		<ctor-func>
			<summary>
				Initializes a new instance of the <see cref="EvaluationScope{T}"/> class with standalone labda expression.
			</summary>
			<param name="func">
				Lambda expression using <see cref="IValue"/> types
			</param>
		</ctor-func>
		<method-ToResult>
			<summary>
				Exit method to return result from inherited calculation
			</summary>
			<returns>Calculation result</returns>
		</method-ToResult>
		<method-Evaluate>
			<summary>Evaluates an expression and captures arguments.</summary>
			<typeparam name="TValue">Result value type</typeparam>
			<param name="lambdaExpression">Math or logic expression</param>
			<param name="name">Result name (captured by the compiler by default)</param>
			<param name="lambdaExpressionBody">Expression body (captured by the compiler by default)</param>
			<returns>Lambda expression result containing arguments and expression body.</returns>
		</method-Evaluate>
	</members>
	<members name="EvaluationScope">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="Value">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="IValue">
		<inteface>
			<summary>
				TBD
			</summary>
		</inteface>
	</members>
	<members name="IValueProvider">
		<inteface>
			<summary>
				TBD
			</summary>
		</inteface>
	</members>
	<members name="MakeValueArgs">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="Number">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="Option">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="Tag">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="TagsCollection">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="Value">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ValueMath">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ValueMath">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ValueOriginType">
		<enum>
			<summary>
				TBD
			</summary>
		</enum>
	</members>
	<members name="ValueVisitor">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ArgumentsCollection">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ArgumentsVisitorInvoker">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="Condition">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="IArguments">
		<inteface>
			<summary>
				TBD
			</summary>
		</inteface>
	</members>
	<members name="ITags">
		<inteface>
			<summary>
				TBD
			</summary>
		</inteface>
	</members>
	<members name="NullExpressionResultException">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ExpressionNode">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ExpressionNodeType">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="IExpression">
		<inteface>
			<summary>
				TBD
			</summary>
		</inteface>
	</members>
	<members name="JsonArgumentsReader">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="JsonArgumentsReader">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="SwitchExpression">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="IValuesProvider">
		<inteface>
			<summary>
				TBD
			</summary>
		</inteface>
	</members>
	<members name="Values">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ValuesDebugView">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
	<members name="ValuesLinqMathExtensions">
		<class>
			<summary>
				TBD
			</summary>
		</class>
	</members>
</docs>