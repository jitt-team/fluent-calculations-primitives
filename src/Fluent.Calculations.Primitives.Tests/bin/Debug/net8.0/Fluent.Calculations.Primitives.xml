<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fluent.Calculations.Primitives</name>
    </assembly>
    <members>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.ArgumentsCollection">
            <summary>Represents read-only collection of IValue elements that are arguments of the expression.</summary><remarks>Created and populated by the operation handlers or EvaluationScope during execution of implemented logic</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.ArgumentsCollection.Count">
            <summary>Gets the number of elements contained in the arguments collection.</summary><remarks>Array will be empty for Constant value type.</remarks><value>Number of elements in a collection</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ArgumentsCollection.GetEnumerator">
            <summary>Returns an enumerator that iterates through the ArgumentsCollection.</summary><remarks>Learn more about native GetEnumerator Method.</remarks><returns>A ArgumentsCollection.Enumerator for the ArgumentsCollection.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.ArgumentsDebugView">
            <summary>Provides a simplified debug view of Expresion class Arguments property.</summary><remarks /><param name="arguments">Arguments collection.</param>
            #pragma warning restore CS1572 // XML comment has a param tag, but there is no parameter by that name
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ArgumentsDebugView.#ctor(Fluent.Calculations.Primitives.BaseTypes.IArguments)">
            <summary>Provides a simplified debug view of Expresion class Arguments property.</summary><remarks /><param name="arguments">Arguments collection.</param>
            #pragma warning restore CS1572 // XML comment has a param tag, but there is no parameter by that name
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.ArgumentsDebugView.Arguments">
            <summary>Use friendly list of expression arguments.</summary><remarks /><value>Lis of arguments</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.ArgumentsVisitorInvoker">
            <summary>Contains methods that enables Visitor functionality of Values.</summary><remarks>Use this class when implementing new Value class in the implementation of Accept() method of IValueProvider.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ArgumentsVisitorInvoker.VisitArguments(Fluent.Calculations.Primitives.BaseTypes.IValue,Fluent.Calculations.Primitives.BaseTypes.ValueVisitor)">
            <summary>Invokes a supplied vistor.</summary><remarks>Visitor will will be invoked for every argument of the supplied value.</remarks><param name="value">Value to be visited.</param><param name="visitor">Vistor that will handle visited value.</param><returns>Returns same value that was supplied.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.Condition">
            <summary>
            TBD
            </summary>
            <remarks>TBD</remarks>
            <param name="makeValueArgs">TBD</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.#ctor(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>
            TBD
            </summary>
            <remarks>TBD</remarks>
            <param name="makeValueArgs">TBD</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.ToString">
            <summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Condition.PrimitiveString">
            <summary>TBDA</summary><remarks>TBDA</remarks><value>TBDA</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.#ctor">
            <summary>TBDA</summary><remarks>TBDA</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Condition.IsTrue">
            <summary>TBDA</summary><remarks>TBDA</remarks><value>TBDA</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.MakeDefault">
            <summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_Implicit(System.Boolean)~Fluent.Calculations.Primitives.BaseTypes.Condition">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="value">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_Implicit(Fluent.Calculations.Primitives.BaseTypes.Condition)~System.Boolean">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="condition">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_True(Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="condition">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_False(Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="condition">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.True(System.String)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="expressionName">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.True(System.String,System.String)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="scope">TBDA</param><param name="expressionName">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.False(System.String)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="expressionName">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.False(System.String,System.String)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="scope">TBDA</param><param name="expressionName">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.MakeOfThisType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="args">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.Equals(System.Object)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="obj">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.GetHashCode">
            <summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_BitwiseAnd(Fluent.Calculations.Primitives.BaseTypes.Condition,Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_BitwiseOr(Fluent.Calculations.Primitives.BaseTypes.Condition,Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_Equality(Fluent.Calculations.Primitives.BaseTypes.Condition,Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_Inequality(Fluent.Calculations.Primitives.BaseTypes.Condition,Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_ExclusiveOr(Fluent.Calculations.Primitives.BaseTypes.Condition,Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Condition.op_OnesComplement(Fluent.Calculations.Primitives.BaseTypes.Condition)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="value">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.IArguments">
            <summary>Provides the interfact to retrieve expression arguments.</summary><remarks>This interface can be used for visualizations or any other output transformations.</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IArguments.Count">
            <summary>Gets the number of elements contained in the arguments collection.</summary><remarks>Array will be empty for Constant value type.</remarks><value>Number of elements in a collection</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.ITags">
            <summary>Provides an iterface to access Tags collection.</summary><remarks />
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.IValue">
            <summary>Lightweight interface that every value class will implement providing access to common properties.</summary><remarks>Visualizations can be base on this interface, ex. Graphs.</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.Type">
            <summary>Original type of the value implementation</summary><remarks>Can be used for more advance desrialization into concrete value types. Examples of names of built in value types are "Number" and "Condition"</remarks><value>Name of type aka GetType().Name</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.Name">
            <summary>Name of value</summary><remarks>Either custom name provided when declaring a value or automatically captured by compiler when using buil-in helper methods.</remarks><value>Sets or gets name, "NaN" when names wasn't set.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.Scope">
            <summary>Named scope that this value is part of</summary><remarks>Scope name can be used for visualizations to group related values and claculations</remarks><value>Scome name</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.Primitive">
            <summary>Numeric primitive representation of the value.</summary><remarks>Decimal is intentinal choice at this point as being most common number type for business related calculations.</remarks><value>Primitive value.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.PrimitiveString">
            <summary>Formatted string representation of the primitive value</summary><remarks>Use this property for graph rendering purposes to have a consistent user-freindly representation of a value.</remarks><value>Inheriting class is responsible of providing an accurate formatting.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.Origin">
            <summary>Origin type of the value.</summary><remarks>Provides an understanding of the origin and classification of a value in respect to it's source and usage.</remarks><value>Origin type.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.Expression">
            <summary>Metadata of expression that yielded this value.</summary><remarks>Entire calculation tree can be discovered by visiting this property starting from final result instance.</remarks><value>Expression metadata.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.IValue.Tags">
            <summary>Custom tags associated with the value.</summary><remarks>Simple mechanism to carry additional meta-data througout the calculation. Can be usefull to provide addtional grouping, identifiers or enything else to look up values.</remarks><value>Custom tag.</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.IValueProvider">
            <summary>Provides a standard interface for all Values that provides methods to support implementation of new operators and domain specific methods.</summary><remarks>Use this class to implement additional calculation functions or operators.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.IValueProvider.MakeOfThisType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>Initializes a new instance of the concrete type.</summary><remarks>Use when implementing new functions and return results of target value type. Returned value should be casted to final type.</remarks><param name="args">Arguments to create a new value.</param><returns>New instance concrete value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.IValueProvider.MakeDefault">
            <summary>Returns the default value of underlying concrete value implementation.</summary><remarks>Casting to target type is responsibility of caller.</remarks><returns>Default value instance.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.IValueProvider.Accept(Fluent.Calculations.Primitives.BaseTypes.ValueVisitor)">
            <summary>Accepts Arguments visitor.</summary><remarks>When value is inhertied from Value base class, doesn't need to be overriden.</remarks><param name="visitor">Arguments visitor.</param><returns>Returns self.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs">
            <summary>Represents set of standard arguments to initialize instance of a class inheriting from Value base class.</summary><remarks>Used in constructors of classes derived from Value class to initialize the base class.</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs.Name">
            <summary>Name of value.</summary><remarks>Either custom name provided when declaring a value or automatically captured by compiler when using buil-in helper methods.</remarks><value>Sets or gets name, "NaN" when names wasn't set.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs.Expression">
            <summary>Metadata of expression that yielded this value.</summary><remarks>Entire calculation tree can be discovered by visiting this property starting from final result instance.</remarks><value>Expression metadata.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs.PrimitiveValue">
            <!-- No matching elements were found for the following include tag --><include file="Docs.xml" path="*/MakeValueArgs/PrimitiveValue/*" />
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs.Origin">
            <summary>Origin type of the value.</summary><remarks>Provides an understanding of the origin and classification of a value in respect to it's source and usage.</remarks><value>Origin type.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs.Tags">
            <summary>Custom tags associated with the value.</summary><remarks>Simple mechanism to carry additional meta-data througout the calculation. Can be usefull to provide addtional grouping, identifiers or enything else to look up values.</remarks><value>Custom tag.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs.Scope">
            <summary>Named scope that this value is part of</summary><remarks>Scope name can be used for visualizations to group related values and claculations</remarks><value>Scome name</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.Number">
            <summary>Represents a numeric type enclosing native decimal value type, it supports arithmetic, comparison, and equality operators.</summary><remarks>Additionally this class implements Generic Math operators.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.ToString">
            <summary>Returns a string that represents the current Number.</summary><remarks>Don't use for rendering results, use PrimitiveString property instead. This method support concise presentation in Debug View.</remarks><returns>Return Name of the Number.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" />.
      </summary><remarks>Equivalent to Zero.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.#ctor(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> by making a deep copy of an existing value.
      </summary><remarks>Useful to create results of derived types.</remarks><param name="number">Exisitng value.</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.#ctor(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> with provided values as arguments.
      </summary><remarks>Used in derived classes to initialize base class fields.</remarks><param name="makeValueArgs">
        Arguments for a new <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> with.
      </param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Implicit(System.Int32)~Fluent.Calculations.Primitives.BaseTypes.Number">
            <summary>
        Implicit converstion from int to <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" />.
      </summary><remarks /><param name="primitiveValue">Integer value.</param><returns>
        <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> representing the int value.
      </returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Implicit(System.Decimal)~Fluent.Calculations.Primitives.BaseTypes.Number">
            <summary>
        Implicit converstion from decimal to <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" />.
      </summary><remarks /><param name="primitiveValue">Decimal value.</param><returns>
        <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> representing the int value.
      </returns>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Number.Zero">
            <summary>
        Returns an <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> instance representing zero value.
      </summary><remarks /><value>Number representing Zero.</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Of(System.Decimal,System.String)">
            <summary>
        Creates a new named <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> instance.
      </summary><remarks>
        This is one of prefered ways to create <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> using a primitive value. Scope of the number will be updated during the evaluation.
      </remarks><param name="primitiveValue">Constant or variable to be used as a Primitive of the new Number.</param><param name="fieldName">Name of the Number (automatically defined by at compile time)</param><returns>
        <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> instance representing the supplied numeric value.
      </returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Of(System.Decimal,System.String,System.String)">
            <summary>
        Creates a new named <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> instance with named scope.
      </summary><remarks>
        This is one of prefered ways to create <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> using a primitive value.
      </remarks><param name="primitiveValue">Constant or variable to be used as a Primitive of the new Number.</param><param name="fieldName">Name of the Number (automatically defined by at compile time)</param><param name="scope">Target scope which the value will be part of.</param><returns>
        <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Number" /> instance representing the supplied numeric value.
      </returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Subtraction(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Addition(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Division(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Multiply(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_LessThan(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns><summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_LessThanOrEqual(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns><summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_GreaterThan(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns><summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_GreaterThanOrEqual(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns><summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Equality(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns><summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>    
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.op_Inequality(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>TBDA</returns><summary>TBDA</summary><remarks>TBDA</remarks><returns>TBDA</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.System#Numerics#IComparisonOperators{Fluent#Calculations#Primitives#BaseTypes#Number,Fluent#Calculations#Primitives#BaseTypes#Number,System#Boolean}#op_GreaterThan(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.System#Numerics#IComparisonOperators{Fluent#Calculations#Primitives#BaseTypes#Number,Fluent#Calculations#Primitives#BaseTypes#Number,System#Boolean}#op_GreaterThanOrEqual(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.System#Numerics#IComparisonOperators{Fluent#Calculations#Primitives#BaseTypes#Number,Fluent#Calculations#Primitives#BaseTypes#Number,System#Boolean}#op_LessThan(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.System#Numerics#IComparisonOperators{Fluent#Calculations#Primitives#BaseTypes#Number,Fluent#Calculations#Primitives#BaseTypes#Number,System#Boolean}#op_LessThanOrEqual(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.System#Numerics#IEqualityOperators{Fluent#Calculations#Primitives#BaseTypes#Number,Fluent#Calculations#Primitives#BaseTypes#Number,System#Boolean}#op_Equality(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.System#Numerics#IEqualityOperators{Fluent#Calculations#Primitives#BaseTypes#Number,Fluent#Calculations#Primitives#BaseTypes#Number,System#Boolean}#op_Inequality(Fluent.Calculations.Primitives.BaseTypes.Number,Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>TBDA</summary><remarks>TBDA</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.MakeOfThisType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>Initializes a new instance of Number class.</summary><remarks>Use this method to create a results of math or logical operations or calculation methods.</remarks><param name="args">Arguments to create a new Number</param><returns>New instance of Number configured with values provided with specified args.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.MakeDefault">
            <summary>Initializes a new Number representing zero decimal.</summary><remarks>Value with all defaults.</remarks><returns>Instance of zero Number.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Equals(System.Object)">
            <summary>Determines whether two Numbers are equal based on underlying primitive value.</summary><remarks>This method is subject to future change. Use equality operator to have type specific equality check.</remarks><param name="obj">Other Number</param><returns>True if primitive values equal, False if obj is of incompatible type.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.GetHashCode">
            <summary>Serves as the default hash function, returns hash of the Primitive property value. This function is a subject to future change.</summary><remarks>Recommended to override in derived types to account for additional parameters.</remarks><returns>A hash code for the current Primitive value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Addition(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Adds the specified Number value to this value.</summary><remarks>Use this method when building derived types.</remarks><param name="right">Value to add.</param><returns>The result of adding right to this value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Subtraction(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Subtracts the specified Number value from this value.</summary><remarks>Use this method when building derived types.</remarks><param name="right">The subtrahend.</param><returns>The result of subtracting right from this value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Multiply(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Multiplies the specified Number value with this value.</summary><remarks>Use this method when building derived types.</remarks><param name="right">The value to multiply.</param><returns>The result of multiplying right from this value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Division(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Divides the this value by specified Number.</summary><remarks>Use this method when building derived types.</remarks><param name="right">The divisior.</param><returns>The result of dividing this value by right.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Equality(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Returns a Condition that indicates whether this and specified value are different.</summary><remarks>Comparision is based on underlying Primitive value.</remarks><param name="right">Value to compare.</param><returns>Condition representing if values are different.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.Inequality(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Returns a Condition that indicates whether this and specified value are equal.</summary><remarks>Comparision is based on underlying Primitive value.</remarks><param name="right">Value to compare.</param><returns>Condition representing if values are equal.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.LessThan(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Returns a <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> that indicates whether this is less than specified value.</summary><remarks>Comparision is based on the underlying Primitive values.</remarks><param name="right">Value to compare.</param><returns><see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> representing if this value is less than the specified value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.GreaterThan(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Returns a <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> that indicates whether this is greater than specified value.</summary><remarks>Comparision is based on the underlying Primitive values.</remarks><param name="right">Value to compare.</param><returns><see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> representing if this value is greater than specified value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.LessThanOrEqual(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Returns a <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> that indicates whether this is less than or equal to specified value.</summary><remarks>Comparision is based on the underlying Primitive values.</remarks><param name="right">Value to compare.</param><returns><see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> representing if this value is less than or equal to specified value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Number.GreaterThanOrEqual(Fluent.Calculations.Primitives.BaseTypes.Number)">
            <summary>Returns a <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> that indicates whether this is greater than or equal to specified value.</summary><remarks>Comparision is based on the underlying Primitive values.</remarks><param name="right">Value to compare.</param><returns><see cref="T:Fluent.Calculations.Primitives.BaseTypes.Condition" /> representing if this value is greater than or equal to specified value.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.Option`1">
            <summary>
        Class that is a logical equivalent to native enum and used to define a set of constant options.
      </summary><remarks>This class enables use of SwithcExpression swithc/case expression builder.</remarks><typeparam name="T">Type of underlying the Enum.</typeparam>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.op_Implicit(Fluent.Calculations.Primitives.BaseTypes.Option{`0})~`0">
            <summary>
        Makes an implicit conversion from the Option to its underlying Enum type.
      </summary><remarks /><param name="value">Option value.</param><returns>Enum value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.op_Implicit(`0)~Fluent.Calculations.Primitives.BaseTypes.Option{`0}">
            <summary>
        Makes an implicit conversion from the Enum type to Option.
      </summary><remarks /><param name="value">Enum value.</param><returns>Option value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.MakeOfThisType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>Initializes a new instance of the Option class.</summary><remarks>Use when implementing functions handling Options to return new Option result.</remarks><param name="args">Arguments to create a new value</param><returns>New instance Option.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.MakeDefault">
            <summary>Initializes a new instance with default values, equivalent to zero/null value.</summary><remarks>This framework avoids dealing with nullable types.</remarks><returns>Instance of deafault value</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.Equals(System.Object)">
            <summary>Determines whether two Values are equal based on underlying primitive value.</summary><remarks>This method is subject to future change. Use equality operator to have type specific equality check.</remarks><param name="obj">Other option</param><returns>True if primitive values equal, False if obj is of incompatible type.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.GetHashCode">
            <summary>Serves as the default hash function, returns hash of the Primitive property value. This function is a subject to future change.</summary><remarks>Recommended to override in derived types to account for additional parameters.</remarks><returns>A hash code for the current Primitive value</returns>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Option`1.PrimitiveString">
            <summary>Formatted string representation of the Option Enum value</summary><remarks>Use this property for graph rendering purposes to have a consistent user-freindly representation of a value.</remarks><value>String representation of underlying Enum value.</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.Switch``1">
            <summary>Invokes Switch expression builder to be used in Evaluate() method of EvaluationScope.</summary><remarks>Current Option will be used to check cases defined by builder.</remarks><typeparam name="TResult">TBDA</typeparam><returns>Switch expression.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.op_Equality(Fluent.Calculations.Primitives.BaseTypes.Option{`0},Fluent.Calculations.Primitives.BaseTypes.Option{`0})">
            <summary>Compares two Options to determine equality.</summary><remarks>Comparision is based on underlying Enum value.</remarks><param name="left">The value to compare with right.</param><param name="right">The value to compare with left.</param><returns>Condition instance that represents true if left is equal to right; otherwise, false.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option`1.op_Inequality(Fluent.Calculations.Primitives.BaseTypes.Option{`0},Fluent.Calculations.Primitives.BaseTypes.Option{`0})">
            <summary>Compares two Options to determine inequality.</summary><remarks>Comparision is based on underlying Enum value.</remarks><param name="left">TBDA</param><param name="right">TBDA</param><returns>Condition instance true if left is not equal to right; otherwise, false</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.Option">
            <summary>Contains methods for typed Option instance creation.</summary><remarks />
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Option.Of``1(``0,System.String)">
            <summary>Creates an instance of an Option prepresenting provided Enum value.</summary><remarks /><typeparam name="TEnum">Underlying Enum type.</typeparam><param name="primitiveValue">Value of the option.</param><param name="fieldName">Automaically captured name of declaring property which will be used as a name of the Option.</param><returns>Option value instance.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.Tag">
            <summary>Lightweight annotation of a Value.</summary><remarks>Used to provide an additinal context or details to values and calculation results.</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Tag.Name">
            <summary>Tag content.</summary><remarks>Tag max length is 255.</remarks><value>Annotation string value.</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Tag.Create(System.String)">
            <summary>Creates new Tag.</summary><remarks /><param name="name">Tag name.</param><returns>New instance of a Tag wit the provided name.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Tag.ToString">
            <summary>Returns a string that represents the Tag.</summary><remarks /><returns>Equals to Name property.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.TagsCollection">
            <summary>Collection of Tag objects.</summary><remarks>Read-only collection of tags.</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.TagsCollection.Count">
            <summary>Gets the number of elements contained in the Tags collection.</summary><remarks /><value>Number of elements in a collection.</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.TagsCollection.GetEnumerator">
            <summary>Returns an enumerator that iterates through the TagsCollection.</summary><remarks>Learn more about native GetEnumerator Method.</remarks><returns>A TagsCollection.Enumerator for the TagsCollection.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.Value">
            <summary>Provides the base class from which the domain specific numer-like classes types can be derived.</summary><remarks>Number and Condition are built-in examples. Leverage this class to create other types specific to your domain. Learn more about implementing new tracable values.</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.Name">
            <summary>Name of value</summary><remarks>Either custom name provided when declaring a value or automatically captured by compiler when using buil-in helper methods.</remarks><value>Sets or gets name, "NaN" when names wasn't set.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.Expression">
            <summary>Metadata of expression that yielded this value.</summary><remarks>Entire calculation tree can be discovered by visiting this property starting from final result instance.</remarks><value>Expression metadata.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.Primitive">
            <summary>Numeric primitive representation of the value.</summary><remarks>Decimal is intentinal choice at this point as being most common number type for business related calculations.</remarks><value>Primitive value.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.PrimitiveString">
            <summary>Formatted string representation of the primitive value</summary><remarks>Use this property for graph rendering purposes to have a consistent user-freindly representation of a value.</remarks><value>Inheriting class is responsible of providing an accurate formatting.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.Origin">
            <summary>Origin type of the value.</summary><remarks>Provides an understanding of the origin and classification of a value in respect to it's source and usage.</remarks><value>Origin type.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.Tags">
            <summary>Custom tags associated with the value.</summary><remarks>Simple mechanism to carry additional meta-data througout the calculation. Can be usefull to provide addtional grouping, identifiers or enything else to look up values.</remarks><value>Custom tag.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.Scope">
            <summary>Named scope that this value is part of</summary><remarks>Scope name can be used for visualizations to group related values and claculations</remarks><value>Scome name</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.#ctor(Fluent.Calculations.Primitives.BaseTypes.Value)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Value" /> which is deep copy of the supplied value parameter.
      </summary><remarks>This constructor is used in constructors of derived types based on a simpler types. For example Money type could based on Number.</remarks><param name="value">Value to copy</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.#ctor(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>
        Initializes a new instance of the <see cref="!:Values" /> with provided values. Used in derived classes to initialize base class fields.
      </summary><remarks>This constructor is complements MakeOfThisType() method to create results of operations and methods handling primitive value calculations.</remarks><param name="makeValueArgs">Arguments to create a new value.</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.MakeOfThisType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>
        Initializes a new instance of the derived value class. Used by the framework to create expected result types.
      </summary><remarks>This method is typically used to create a results of math or logical operations or calculation methods, build int ValueMath.Abs() would be an example.</remarks><param name="args">Arguments to create a new value</param><returns>New instance of same type.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.MakeDefault">
            <summary>Initializes a new instance with default values, equivalent to zero/null value.      </summary><remarks>This framework avoids dealing with nullable types.</remarks><returns>Instance of zero value</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.HandleBinaryOperation``2(Fluent.Calculations.Primitives.BaseTypes.IValueProvider,System.Func{Fluent.Calculations.Primitives.BaseTypes.IValueProvider,Fluent.Calculations.Primitives.BaseTypes.IValueProvider,``1},System.String)">
            <summary>
        Handles math and comparison operations of underlying primitve values in derived types.
      </summary><remarks>Examples are Number and Condition classes that are using this method.</remarks><typeparam name="ResultType">Operation result type</typeparam><typeparam name="ResultPrimitiveType">.NET primitive value type (ex. decimal, boolean)</typeparam><param name="right">Right side value of operatoin</param><param name="expressionFunc">Expression representing operation in derived type</param><param name="operatorName">Operation name (ex. Add, Substract, LessThan)</param><returns>Result value of defined type containg input values as arguments</returns>
        </member>
        <member name="P:Fluent.Calculations.Primitives.BaseTypes.Value.Type">
            <summary>Original type of the value implementation.</summary><remarks>Can be used for more advance desrialization into concrete value types. Examples of names of built in value types are "Number" and "Condition"</remarks><value>Name of type aka GetType().Name</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.Equals(Fluent.Calculations.Primitives.BaseTypes.IValueProvider)">
            <summary>
        Determines whether two Values are equal based on underlying primitive value.
      </summary><remarks>This method is subject to future change. Use equality operator to have type specific equality check.</remarks><param name="value">Other value</param><returns>True if primitive values equal.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.Equals(System.Object)">
            <summary>Determines whether two Values are equal based on underlying primitive value.</summary><remarks>This method is subject to future change. Use equality operator to have type specific equality check.</remarks><param name="obj">Other value</param><returns>True if primitive values equal, False if obj is of incompatible type.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.GetHashCode">
            <summary>Serves as the default hash function, returns hash of the Primitive property value. This function is a subject to future change.</summary><remarks>Recommended to override in derived types to account for additional parameters.</remarks><returns>A hash code for the current Primitive value</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.Value.ToString">
            <summary>Returns a string that represents the current value object.</summary><remarks>Derived types are responsible of implementating prefered string representation. Primary use case is readability in Debug View, to make user fiendly representation leverage PrimitiveString property.</remarks><returns>Return Name of value as a default implementation.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.ValueMath">
            <summary>Provides static methods for common mathematical functions for types implementing IValueProvider.</summary><remarks>This class is an wrapper of native Math class in .NET Framework and enables the capturing of arguments. This library focuses on simpler business related calculations hence many trigonometric or logarithmic functions ar ommited at the moment.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueMath.Abs``1(``0)">
            <summary>Returns the absolute value of a Value.</summary><remarks>Please refer to .NET Math.Abs(Decimal) documentation for more details.</remarks><typeparam name="T">Type of value</typeparam><param name="value">Value to get Absolute for</param><returns>Value containing the primitive result, expression name and input value as an argument.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueMath.Ceiling``1(``0)">
            <summary>Returns the smallest integral value that is greater than or equal to the specified underlying decimal number.</summary><remarks>Please refer to .NET Math.Ceiling(Decimal) documentation for more details.</remarks><typeparam name="T">Type of value</typeparam><param name="value">Value to get Ceiling for</param><returns>Value containing the primitive result, expression name and input value as an argument.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueMath.Floor``1(``0)">
            <summary>Returns the largest integral value less than or equal to the specified underlying decimal number.</summary><remarks>Please refer to .NET Math.Floor(Decimal) documentation for more details.</remarks><typeparam name="T">Type of value</typeparam><param name="value">Value to get Floor for</param><returns>Value containing the primitive result, expression name and input value as an argument.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueMath.Truncate``1(``0)">
            <summary>Calculates the integral part of a specified underlying decimal number.</summary><remarks>Please refer to .NET Math.Truncate(Decimal) documentation for more details.</remarks><typeparam name="T">Type of value</typeparam><param name="value">Value to Truncate</param><returns>Value containing the primitive result, expression name and input value as an argument.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueMath.Min``1(``0,``0)">
            <summary>Returns the smaller of two values.</summary><remarks>Please refer to .NET Math.Min(Decimal, Decimal) documentation for more details.</remarks><typeparam name="T">Type of value</typeparam><param name="val1">The first of two numbers to compare</param><param name="val2">The second  of two numbers to compare</param><returns>New value of type T which has a primitive result of val1 or val2, whichever is smaller. It will also contain expression name and bith input parameters as arguments.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueMath.Max``1(``0,``0)">
            <summary>Returns the larger of two values.</summary><remarks>Please refer to .NET Math.Min(Decimal, Decimal) documentation for more details.</remarks><typeparam name="T">Type of value</typeparam><param name="val1">The first of two numbers to compare</param><param name="val2">The second  of two numbers to compare</param><returns>New value of type T which has a primitive result of val1 or val2, whichever is larger. It will also contain expression name and bith input parameters as arguments.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueMath.Round``1(``0,``0)">
            <summary>
        Rounds a decimal value to a specified underlying number of fractional digits, and rounds midpoint values to the nearest even number.
      </summary><remarks>Please refer to .NET Math.Round(Decimal, Int32) documentation for more details.</remarks><typeparam name="T">Type of value</typeparam><param name="d">A number to be rounded.</param><param name="decimals">The number of decimal places in the return value.</param><returns>The value with the number nearest to d that contains a number of fractional digits equal to decimals, expression name and input value as an argument.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.ValueOriginType">
            <summary>Defines the origin of value in context of a calculation.</summary><remarks>This enum allows quick understanding of the flow of the calculation.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.BaseTypes.ValueOriginType.NaN">
            <summary>Represents default state when origin is not determinated or set.</summary><remarks>Part of null object pattern, should not apper too often. Value with this origin might indicate some missing implementation.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.BaseTypes.ValueOriginType.Parameter">
            <summary>Represents input parameter of the calculation.</summary><remarks>This value will be applied to values that are not constants or evaluation results within calculation chain.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.BaseTypes.ValueOriginType.Constant">
            <summary>Represents a constant values which do not change.</summary><remarks>Conceptually equal to native constant value.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.BaseTypes.ValueOriginType.Evaluation">
            <summary>Represents a value that is a result of lambda expression evaluation result.</summary><remarks>Only Evaluate() method of EvaluationScope will return this type.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.BaseTypes.ValueOriginType.Operation">
            <summary>Represents intermediate results of basic binary or unary operations.</summary><remarks>These kind of values will typically be filtered out from evaluations. Neverless can be produced when Values are used for standalone operations without calling Evaluate() method.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.BaseTypes.ValueOriginType.Result">
            <summary>Represent the final result value when used in classes inherting from EcaluationScope.</summary><remarks>ToResult() will yield this type.</remarks>
        </member>
        <member name="T:Fluent.Calculations.Primitives.BaseTypes.ValueVisitor">
            <summary>
        Represents a read-only visitor for value arguments.
      </summary><remarks>This class is designed to be inherited to create more specialized classes whose functionality requires traversing, examining expression arguments.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueVisitor.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.BaseTypes.ValueVisitor" />.
      </summary><remarks />
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueVisitor.Visit(Fluent.Calculations.Primitives.BaseTypes.IValue)">
            <summary>Dispatches the the list of arguments to VisitArgument method in this class.</summary><remarks>Initate this method with the value that should be visited, typically a calculation result.</remarks><param name="value">Value whose arguments should be visited.</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.BaseTypes.ValueVisitor.VisitArgument(Fluent.Calculations.Primitives.BaseTypes.IValue)">
            <summary>The argument value to visit.</summary><remarks>Override this method to implement custom value examination logic.</remarks><param name="value">Returns the original visited value.</param>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Collections.IValuesProvider`1">
            <summary>Provides a standard interface for all value collections that provides methods to support implementation of new operators and domain specific aggregate methods.</summary><remarks>Usefull keep track of same kind of values while ussing aggregate functions results in calculations.</remarks><typeparam name="T">Type of collection element</typeparam>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.IValuesProvider`1.MakeOfThisElementType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>Initializes a new instance of collection element type.</summary><remarks>Method is used to implement aggregate collection methods where the result is single value, examples are methods like Sum(), Min() or Max().</remarks><param name="args">Arguments to create a new value.</param><returns>New instance concrete value.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Collections.Values`1">
            <summary>Represents both, a strongly typed read-ony list of Values, and a value that is Sum of all elements.</summary><remarks>Usefull keep track of same kind of values while ussing aggregate functions results in calculations.</remarks><typeparam name="T">Type of collection element</typeparam>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.Values`1.ToString">
            <summary>Returns a string that represents the current collection object.</summary><remarks /><returns>Return Name of value as a default implementation.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.Values`1.Add(`0)">
            <summary>Adds a value to the end of the Values collection.</summary><remarks>This method allows implicit collection initialization of a collection.</remarks><param name="value">Value to be added.</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.Values`1.#ctor(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Value" /> with provided values. Used in derived classes to initialize base class fields.
      </summary><remarks>This constructor is complements MakeOfThisType() method to create results of operations and methods handling primitive value calculations.</remarks><param name="makeValueArgs">Arguments to create a new Collection of values.</param>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Name">
            <summary>Name of values collection</summary><remarks>Either custom name provided when declaring a value or automatically captured by compiler when using buil-in helper methods.</remarks><value>Sets or gets name, "NaN" when names wasn't set.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Primitive">
            <summary>Numeric primitive representation of the sum of all Primitive values in the collection.</summary><remarks>Provides an opportunity for implementing operators so collection can be used in same manner as standalone value. Using Sum() method would be a default choice.</remarks><value>Primitive value of sum of all elements.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Origin">
            <summary>Origin type of the value.</summary><remarks>Provides an understanding of the origin and classification of a value in respect to it's source and usage.</remarks><value>Origin type.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Expression">
            <summary>Metadata of expression that yielded this value.</summary><remarks>Entire calculation tree can be discovered by visiting this property starting from final result instance.</remarks><value>Expression metadata.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Tags">
            <summary>Custom tags associated with the collection.</summary><remarks>Simple mechanism to carry additional meta-data througout the calculation. Can be usefull to provide addtional grouping, identifiers or enything else to look up values.</remarks><value>Custom tag.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Scope">
            <summary>Named scope that this value is part of</summary><remarks>Scope name can be used for visualizations to group related values and claculations</remarks><value>Scome name</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.Values`1.MakeOfThisType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>Initializes a new instance of the concrete Values collection.</summary><remarks>Use when implementing new functions and return results of target value type. Returned value should be casted to final type. Use this method to implement filtering methods that return a subset or manipulated collecition.</remarks><param name="args">Arguments to create a new value.</param><returns>New instance concrete collection.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.Values`1.MakeOfThisElementType(Fluent.Calculations.Primitives.BaseTypes.MakeValueArgs)">
            <summary>Initializes a new instance of collection element type.</summary><remarks>Method is used to implement aggregate collection methods where the result is single value, examples are methods like Sum(), Min() or Max().</remarks><param name="args">Arguments to create a new value.</param><returns>New instance concrete value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.Values`1.MakeDefault">
            <summary>Returns the default value empty collection of a concrete type.</summary><remarks>Casting to target type is responsibility of caller.</remarks><returns>Default collection instance.</returns>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Type">
            <summary>Original type of the the collection implementation.</summary><remarks>Can be used for more advance desrialization into concrete value types.</remarks><value>Name of type aka GetType().Name</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.Count">
            <summary>Gets the number of elements contained in the Values collection.</summary><remarks /><value>Number of elements in a collection.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.Values`1.PrimitiveString">
            <summary>Formatted string representation of the Primitive value</summary><remarks>Use this property for graph rendering purposes to have a consistent user-freindly representation of a value.</remarks><value>Inheriting class is responsible of providing an accurate formatting.</value>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.Values`1.Accept(Fluent.Calculations.Primitives.BaseTypes.ValueVisitor)">
            <summary>Accepts Arguments visitor.</summary><remarks>When value is inhertied from Values collection base class, doesn't need to be overriden.</remarks><param name="visitor">Collection items visitor.</param><returns>Returns self.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Collections.ValuesDebugView">
            <summary>Provides a simplified debug view of Values collection class.</summary><remarks />
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.ValuesDebugView.#ctor(Fluent.Calculations.Primitives.BaseTypes.IValue)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.Collections.ValuesDebugView" />.
      </summary><remarks /><param name="collectionValue">Values collection.</param>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Collections.ValuesDebugView.Items">
            <summary>Use friendly list of values.</summary><remarks /><value>Lsit of values.</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Collections.ValuesLinqMathExtensions">
            <summary>Provides static methods of common aggregate functions for types implementing IValuesProvider.</summary><remarks>This class is an wrapper of limited set of native Linq extension methods and enables the capturing collection elements as arguments. Methods will allways return a new instance of value to maintain the relationship with the source collection.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.ValuesLinqMathExtensions.Sum``1(Fluent.Calculations.Primitives.Collections.IValuesProvider{``0})">
            <summary>Computes the sum of a values in a collection.</summary><remarks>Computation is based on Primitive property of the individual value objects.</remarks><typeparam name="TSource">Type of collection items.</typeparam><param name="source">A sequence of values to calculate the sum of.</param><returns>New value of TSource type representing the sum of the values in the sequence.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.ValuesLinqMathExtensions.Average``1(Fluent.Calculations.Primitives.Collections.IValuesProvider{``0})">
            <summary>Computes the average of a values in a collection.</summary><remarks>Computation is based on Primitive property of the individual value objects.</remarks><typeparam name="TSource">Type of collection items.</typeparam><param name="source">A sequence of values to calculate the average of.</param><returns>New value of TSource type representing the avaerage of the values in the sequence.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.ValuesLinqMathExtensions.Min``1(Fluent.Calculations.Primitives.Collections.IValuesProvider{``0})">
            <summary>Returns the minimum of a values in a collection.</summary><remarks>Determination is based on Primitive property of the individual value objects.</remarks><typeparam name="TSource">Type of collection items.</typeparam><param name="source">A sequence of values to determine the minimum value of.</param><returns>New value of TSource type representing the minimum of the values in the sequence.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Collections.ValuesLinqMathExtensions.Max``1(Fluent.Calculations.Primitives.Collections.IValuesProvider{``0})">
            <summary>Returns the maximum of a values in a collection.</summary><remarks>Determination is based on Primitive property of the individual value objects.</remarks><typeparam name="TSource">Type of collection items.</typeparam><param name="source">A sequence of values to determine the maximum value of.</param><returns>New value of TSource type representing the maximum of the values in the sequence.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.EvaluationOptions">
            <summary>
        Provides options to be used with <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" />.
      </summary><remarks>Learn more about EvaluationScope behaviours.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationOptions.#ctor">
            <summary>Initializes a new instance of the EvaluationOptions class.</summary><remarks />
        </member>
        <member name="P:Fluent.Calculations.Primitives.EvaluationOptions.Default">
            <summary>Constructs a new EvaluationOptions instance with a predefined set of defaults.</summary><remarks /><value>Instance of EvaluationOptions class with default options.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.EvaluationOptions.AlwaysReadNamesFromExpressions">
            <summary>Instructs EvaluationScope to read argument names from Expression Tree.</summary><remarks>By default, when evaluations are implemented as methods or properties, name will be captured at compile time. When using local variables without providing custom name, enable this option to read arguemnt names from Expressions.</remarks><value>true: read names from expressions, false: keep default behaviour.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.EvaluationOptions.Scope">
            <summary>Get or sets scope name that will be applied to all values used with EvaluationScope.</summary><remarks>This is one of few ways to provide a scope name. Learn more about evaluation scopes.</remarks><value>Scope name</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.EvaluationScope">
            <summary>Class provides methods to write calculations and capture the results.</summary><remarks>This class provides a logical context of closely related expressions to calculate a result.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" />.
      </summary><remarks>Default options will be applied.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope.#ctor(Fluent.Calculations.Primitives.EvaluationOptions)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" /> class with custom options.
      </summary><remarks>Learn more about evaluation behaviours.</remarks><param name="options">Options to be used to run the calculation.</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope.#ctor(System.String)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" /> class with standalone lambda expression.
      </summary><remarks>This initalization method is mostly sseful for testing and prototyping.</remarks><param name="scope">Name of the scope</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope.Create(System.String)">
            <summary>Create a cope instance.</summary><remarks>Used for standalone EvaluationScpes as opposed to inheritance approach.</remarks><param name="scope">Name of the scope.</param><returns>Named evaluation scope instance.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope.Evaluate``2(System.Func{Fluent.Calculations.Primitives.SwitchExpression{``0,``1}.ResultEvaluator},System.String)">
            <summary>Evaluates switch expression and captures it's values as arguments.</summary><remarks>Learn more about Option type and SwitchExpression.</remarks><typeparam name="TCase">Type of case and evaluated value.</typeparam><typeparam name="TValue">Case result return type.</typeparam><param name="getResultEvaluatorFunc">Expression representing switch expression.</param><param name="name">Name of evauation.</param><returns>Switch expression case result.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope.Evaluate``1(System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.String)">
            <summary>Evaluates an expression and captures it's arguments.</summary><remarks>This is a primary method to define any intermediate calculations in your business logic.</remarks><typeparam name="TValue">Result value type.</typeparam><param name="lambdaExpression">Math or logic expression.</param><param name="name">Result name (captured by the compiler by default).</param><param name="lambdaExpressionBody">Expression body (captured by the compiler by default).</param><returns>Lambda expression result containing arguments and expression body.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope.ClearCache">
            <summary>Force clearing cached evaluation results.</summary><remarks>Experimental feature for resuable calculation classes.</remarks>
        </member>
        <member name="T:Fluent.Calculations.Primitives.EvaluationScope`1">
            <summary>Provides the base class from which the use-case specific calculations classes can be derived.</summary><remarks>
        <para>Create inhertited classes from this base class to define, run and retrieve a result of your calculations.</para>
        <list type="table">
          <item>
            <term>Calculation</term>
            <description>
              <para />
              Your class inheriting from EvaluationScope<![CDATA[<T>]]> is a logical unit to compute desired result. Place lambda expressions,<br />
              input parameters or constants of types derived from <see cref="T:Fluent.Calculations.Primitives.BaseTypes.Value" /> or <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" /> in your derived implementation.
            </description>
          </item>
          <item>
            <term>Examples</term>
            <description>
              <para>Inheriting from EvaluationScope<![CDATA[<T>]]>, where T is a result class type returned by ToResult() method.</para>
              <code>
                public class ExampleCalculation : EvaluationScope<![CDATA[<Number>]]>
                {
                public ExampleCalculation() : base(new EvaluationOptions { AlwaysReadNamesFromExpressions = true }) { }
                public override Number Return() =&gt; Number.Of(0);
                }
              </code>
            </description>
          </item>
          <item>
            <a href="https://fcp-project.jitt.me/docs/category/tutorial---basics/">
              Learn more
            </a>
          </item>
        </list>
      </remarks><typeparam name="T">Type of the result value class.</typeparam>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope`1.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope`1" />.
      </summary><remarks>Default options will be applied.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope`1.#ctor(Fluent.Calculations.Primitives.EvaluationOptions)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope`1" /> class with custom options.
      </summary><remarks>Learn more about evaluation behaviours.</remarks><param name="options">Options to control the behavior during evaluation.</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope`1.#ctor(System.String)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope`1" /> class with standalone lambda expression.
      </summary><remarks>This initalization method is mostly useful for testing and prototyping purposes.</remarks><param name="scope">Name of the scope</param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope`1.#ctor(System.Func{Fluent.Calculations.Primitives.EvaluationScope{`0},`0})">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope`1" /> class with standalone labda expression.
      </summary><remarks>Useful to capture small ad-hoc expressions for tests or experimentation purposes.</remarks><param name="func">
        Lambda expression using <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" /> types.
      </param>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope`1.ToResult">
            <summary>Runs and return result from implemented calculation.</summary><remarks>Calls Return() under the hood.</remarks><returns>Calculation result with captured arguments and expression tree.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.EvaluationScope`1.Return">
            <summary>Override to implement the final calculation step.</summary><remarks>
        Used to explicitly define a final calculation result. Can be considered an equivalent of "return X" in a normal function. Will be executed on ToResult() call of <see cref="T:Fluent.Calculations.Primitives.EvaluationScope`1" />.
      </remarks><returns>Calculation final result.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Expressions.Capture.NullExpressionResultException">
            <summary>The exception that is thrown when a some part of evaluation resulted in a null reference.</summary><remarks>Typically indicates that input parameter was not set.</remarks>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Expressions.ExpressionNode">
            <summary>Class that is used to capture metadata and relationships of expression that produced the Values.</summary><remarks>This is central class to discover full calculation tree of any Value.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Expressions.ExpressionNode.ToString">
            <summary>Returns a string that represents the expression object.</summary><remarks>Output will depend on each function or operaor implementation.</remarks><returns>String containing Body of the expression.</returns>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Expressions.ExpressionNode.Body">
            <summary>Body of the expression or operation.</summary><remarks>Exact body of expression will contain language operators and variable names used in original code.</remarks><value>Expression body</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Expressions.ExpressionNode.Type">
            <summary>Type of method how the value was obtained.</summary><remarks>Usefull for visualizations to customise the rendering of value nodes depending on the way they were produced.</remarks><value>Expression type.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Expressions.ExpressionNode.Arguments">
            <summary>Links the result with the arguments of the expression.</summary><remarks>Arguments can be results of other Evaluaitons. In case of Constants and Input parameters this array will be empty.</remarks><value>List of arguments of the expression.</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType">
            <summary>Contains the classifiers representing Expression types that produced the value.</summary><remarks>This is a concise classification of way the value was obtained. This supplements the Origin enum to create a more granural understaning.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType.None">
            <summary>Represents a standalone value or a default state not related to any EvaluationScope.</summary><remarks>Should not be encountered in typical use cases, should be considered equivalent to not initialized variable.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType.Constant">
            <summary>Represents a definition of an inline constant or an input parameter.</summary><remarks>Constants are values that are not a result of any Evaluation or operation.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType.Collection">
            <summary>Represents a creation of an immuatable collection of values of same type.</summary><remarks>Collection might be a result of a function handling collections, hard-coded collection of constants or an input parameter of a calculation.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType.Lambda">
            <summary>Represents a lambda expression evaluation by Evaluate method of EvaluationScope.</summary><remarks>This type can only be a result of Evaluate() method.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType.Switch">
            <summary>Represents a special case evaluation where SwitchExpression class is being used.</summary><remarks>This type is logical equivalent to native switch/case statement.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType.BinaryExpression">
            <summary>Represents an binary or unary operation.</summary><remarks>Typically values of these types are intermediate results of longer lambda expressions or standalon operations with values.</remarks>
        </member>
        <member name="F:Fluent.Calculations.Primitives.Expressions.ExpressionNodeType.MathExpression">
            <summary>Represents a ValueMath function call.</summary><remarks>Examples are functions like Min() or Max().</remarks>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Expressions.IExpression">
            <summary>Provides the interfact to retrieve expression metadata.</summary><remarks>This interface can be used for visualizations or any other output transformations.</remarks>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Expressions.IExpression.Arguments">
            <summary>Links the result with the arguments of the expression.</summary><remarks>Arguments can be results of other Evaluaitons. In case of Constants and Input parameters this array will be empty.</remarks><value>List of arguments of the expression.</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Expressions.IExpression.Body">
            <summary>Body of the expression or operation.</summary><remarks>Exact body of expression will contain language operators and variable names used in original code.</remarks><value>Expression body</value>
        </member>
        <member name="P:Fluent.Calculations.Primitives.Expressions.IExpression.Type">
            <summary>Type of method how the value was obtained.</summary><remarks>Usefull for visualizations to customise the rendering of value nodes depending on the way they were produced.</remarks><value>Expression type.</value>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Expressions.IValuesCache">
            <!-- No matching elements were found for the following include tag --><include file="Docs.xml" path="*/IValuesCache/interface/*" />
        </member>
        <member name="T:Fluent.Calculations.Primitives.IEvaluationScope">
            <summary>
        Provides an interface to an <see cref="T:Fluent.Calculations.Primitives.EvaluationScope`1" /> object.
      </summary><remarks>Useful for mocking, dependency injection or creating alternative implementations.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.IEvaluationScope.Evaluate``1(System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.String)">
            <summary>Evaluates an expression and captures it's arguments.</summary><remarks>TBDA</remarks><typeparam name="TValue">Result value type.</typeparam><param name="lambdaExpression">Math or logic expression.</param><param name="name">Result name (captured by the compiler by default).</param><param name="lambdaExpressionBody">Expression body (captured by the compiler by default).</param><returns>Lambda expression result containing arguments and expression body.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.IEvaluationScope.Evaluate``2(System.Func{Fluent.Calculations.Primitives.SwitchExpression{``0,``1}.ResultEvaluator},System.String)">
            <summary>Evaluates switch expression and captures it's values as arguments.</summary><remarks>Learn more about Option type and SwitchExpression.</remarks><typeparam name="TCase">Type of case and evaluated value.</typeparam><typeparam name="TValue">Case result return type.</typeparam><param name="getResultEvaluatorFunc">Expression representing switch expression.</param><param name="name">Name of evauation.</param><returns>Switch expression case result.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.IEvaluationScope`1">
            <summary>
        Provides an interface to an <see cref="T:Fluent.Calculations.Primitives.EvaluationScope`1" /> object.
      </summary><remarks>Useful when implementing a strategy pattern. Learn more about advanced use-cases.</remarks><typeparam name="T">Type of the result value class.</typeparam>
        </member>
        <member name="M:Fluent.Calculations.Primitives.IEvaluationScope`1.ToResult">
            <summary>Runs and return result from implemented calculation.</summary><remarks>Calls Return() under the hood.</remarks><returns>Calculation result with captured arguments and expression tree.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Json.ValueJsonSerializer">
            <summary>
        Provides functionality to serialize objects implementing <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" /> interface to JSON and to deserialize JSON into objects implementing <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" /> interface.
      </summary><remarks>For more information, see "How to serialize and deserialize JSON." TODO : add link</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Json.ValueJsonSerializer.Serialize(Fluent.Calculations.Primitives.BaseTypes.IValue,System.Boolean)">
            <summary>Converts the provided value into a String.</summary><remarks>TBDA</remarks><param name="value">The value to convert.</param><param name="writeIndented">Specifies whether JSON should use pretty printing. By default, JSON is serialized without any extra white space.</param><returns>A String representation of the value.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Json.ValueJsonSerializer.Deserialize(System.String)">
            <summary>
        Parses the text representing a single JSON value into a universal ValueDto implementing <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" />.
      </summary><remarks>Returned type and related arguments are not originally serialized types.</remarks><param name="json">JSON text to parse.</param><returns>
        A <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" /> representation of the JSON value.
      </returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Result">
            <summary>Provides methods to execute simple ad-hoc calculations.</summary><remarks>Useful for unit tests or prototyping.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Result.Of``1(System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.String)">
            <summary>Evaluates expression and captures it's arguments.</summary><remarks>Temporary EvaluationScope will be created to evaluate the expression.</remarks><typeparam name="TValue">Type of result.</typeparam><param name="name">Name of resulting value, set by default to calling method or property name.</param><param name="lambdaExpression">Expression to evaluate.</param><param name="lambdaExpressionBody">Expression body, autmatically captured.</param><returns>Evaluation result.</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Result.OfWithScope``1(System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.String,System.String)">
            <summary>Provides methods to execute simple ad-hoc calculations.</summary><remarks>Temporary EvaluationScope will be created to evaluate the expression.</remarks><typeparam name="TValue">Type of result.</typeparam><param name="name">&gt;Name of resulting value, set by default to calling method or property name.</param><param name="lambdaExpression">Expression to evaluate.</param><param name="lambdaExpressionBody">Expression body, autmatically captured</param><param name="scopeName">TBDA</param><returns>Evaluation result.</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.Scope">
            <summary>
        Provides static methods for quick <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" /> creation.
      </summary><remarks>
        Helper class to provide alternative ways to create an <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" /> instances.
      </remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.Scope.CreateHere(System.Object,System.String)">
            <summary>
        Initializes a new instance of the <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" />.
      </summary><remarks>Typically one scope per method would be required to capture logical group of expressions.</remarks><param name="obj">
        Object where <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" /> to be crated. Class name will be used as a prefix of the scope name.
      </param><param name="scope">Scope name, by default calling method name will be captured.</param><returns>
        Inctance of <see cref="T:Fluent.Calculations.Primitives.EvaluationScope" />.
      </returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.SwitchExpression`2">
            <summary>Provides support of swithc/case logic building using fluent builder pattern.</summary><remarks>
        Use the funtionality provided by this builder instead of native swithc/case statements as it's not supported in Expressions.
      </remarks><typeparam name="T">Type of condition</typeparam><typeparam name="TReturn">Result type</typeparam>
        </member>
        <member name="M:Fluent.Calculations.Primitives.SwitchExpression`2.For(Fluent.Calculations.Primitives.BaseTypes.Option{`0})">
            <summary>
        Specifies option variable to check
      </summary><remarks>TBDA</remarks><param name="checkValue">Value to check</param><returns>Swich part configurator</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.SwitchExpression`2.SwitchBuilder">
            <summary>
          Switch case part builder
        </summary><remarks>Equivalent to 'case x :' in native C#</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.SwitchExpression`2.SwitchBuilder.Case(`0,`0[])">
            <summary>
          Define a single or multiple cases to check
        </summary><remarks>TBDA</remarks><param name="caseValue">Value of single case</param><param name="otherCaseValues">Other cases</param><returns>Return value builder</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.SwitchExpression`2.ReturnBuilder">
            <summary>
          Case return part buider
        </summary><remarks>TBDA</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.SwitchExpression`2.ReturnBuilder.Return(System.Decimal)">
            <summary>
          Define a primitive numeric value as a result of case.
        </summary><remarks>Use to define well-know numeric constants</remarks><param name="primitiveValue">Value to return when case is matched</param><returns>Next case builder</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.SwitchExpression`2.ReturnBuilder.Return(System.Func{`1},System.String)">
            <summary>
          Define a function that returns <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" /> as a result of case
        </summary><remarks>TBDA</remarks><param name="returnValueFunc">Function returning expected result</param><param name="funcBody">Name of function will be automatically captured as a default. Can be manually overriden.</param><returns>Next case builder</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.SwitchExpression`2.CaseBuilder">
            <summary>
          Next or default case part builder
        </summary><remarks>Build another case or end the daisy-chain with default case.</remarks>
        </member>
        <member name="M:Fluent.Calculations.Primitives.SwitchExpression`2.CaseBuilder.Case(`0,`0[])">
            <summary>
          Define a single or multiple cases to check
        </summary><remarks>TBDA</remarks><param name="caseValue">Value of single case</param><param name="otherCaseValues">Other cases</param><returns>Return value builder</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.SwitchExpression`2.CaseBuilder.Default(System.Decimal,System.String)">
            <summary>
          Define primitive numeric value as a default case result.
        </summary><remarks>TBDA</remarks><param name="primitiveValue">TBDA</param><param name="valueBody">TBDA</param><returns>Result evaluator</returns>
        </member>
        <member name="M:Fluent.Calculations.Primitives.SwitchExpression`2.CaseBuilder.Default(System.Func{`1},System.String)">
            <summary>
          Define a function that returns <see cref="T:Fluent.Calculations.Primitives.BaseTypes.IValue" /> as a default case result.
        </summary><remarks>TBDA</remarks><param name="defaultValueFun">Function returning expected result</param><param name="funcBody">Name of function will be automatically captured as a default. Can be manually overriden.</param><returns>Result evaluator</returns>
        </member>
        <member name="T:Fluent.Calculations.Primitives.SwitchExpression`2.ResultEvaluator">
            <summary>
          Class that will allow EvaluationContext to execute the configured Switch/Case expression.
        </summary><remarks>Used as an input of Evalueate() overload of EvaluationScope class.</remarks>
        </member>
    </members>
</doc>
